from langgraph.constants import Send
from Classes.state_classes import OverallState

################################################################
# MAIN NODES & GRAPH
################################################################

def continue_to_components(state: OverallState):
    """
    Instead of calling 'generate_component', we now invoke our
    'generate_specialized_subchart'.
    """
    # We'll pass each component as 'component' into the subchart
    # and collect the returns
    return [Send("generate_component_subchart", {"component": c}) for c in state["Components"]]


def update_json_layout(state: OverallState):
    components_configs = state["JsonLayoutWithComponentConfig"]
    updated_layout = state["JsonLayout"]

    def walk_and_update(layout, configs):
        if isinstance(layout, dict):
            if "components" in layout and isinstance(layout["components"], list):
                for component in layout["components"]:
                    for config in configs:
                        if config["id"] == component.get("id"):
                            component.update(config["generatedConfig"])
            for v in layout.values():
                walk_and_update(v, configs)
        elif isinstance(layout, list):
            for v in layout:
                walk_and_update(v, configs)

    walk_and_update(updated_layout, components_configs)
    return {"JsonLayout": updated_layout}


def gatheruniquelists(state: OverallState):
    """
    Gathers all unique 'lists' definitions from the newly generated 
    component configs and stores them in the 'Lists' field of the state.
    """
    new_lists = []
    
    for component_config in state.get("JsonLayoutWithComponentConfig", []):
        generated_config = component_config.get("generatedConfig", {})
        config_obj = generated_config.get("config", {})
        comp_lists = config_obj.get("lists", [])

        # Add only unique list definitions
        for list_def in comp_lists:
            if list_def not in new_lists:
                new_lists.append(list_def)

    state["Lists"] = new_lists

    return {"Lists": new_lists}

def remove_none_members(data):
    """
    Recursively removes all None members from a JSON-like dictionary or list structure.
    """
    if isinstance(data, dict):
        return {k: remove_none_members(v) for k, v in data.items() if v is not None}
    elif isinstance(data, list):
        return [remove_none_members(item) for item in data if item is not None]
    else:
        return data

def consolidate_lists_to_layout(state: OverallState):
    """
    Consolidates all the lists generated by the subgraph into the final layout JSON.
    """
    if "JsonLayout" not in state or state["JsonLayout"] is None:
        state["JsonLayout"] = {}

    # Ensure we have a lists dictionary
    if "lists" not in state["JsonLayout"]:
        state["JsonLayout"]["lists"] = {}

    generated_lists = state.get("JsonLists", {})

    for generated_list in generated_lists:
        if isinstance(generated_list, dict):
            state["JsonLayout"]["lists"].update(generated_list)
    
    return {"JsonLayout": state["JsonLayout"], "JsonLayoutList": [state["JsonLayout"]]}
